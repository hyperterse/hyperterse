import { $ } from "bun";
import { resolve, dirname } from "node:path";
import { mkdirSync } from "node:fs";

// Ensure we're in the project root
const scriptDir = dirname(new URL(import.meta.url).pathname);
const projectRoot = resolve(scriptDir, "..");
$.cwd(projectRoot);

const [connectorsProtoFile, primitivesProtoFile] = process.argv.slice(2);

if (!connectorsProtoFile || !primitivesProtoFile) {
  console.error(
    `Usage: bun run ${process.argv[1]} <connectors-proto-file> <primitives-proto-file>`
  );
  process.exit(1);
}

// Types
interface EnumValue {
  protoName: string; // e.g., "CONNECTOR_POSTGRES"
  stringVal: string; // e.g., "postgres"
}

interface EnumInfo {
  name: string;
  values: EnumValue[];
}

// Read proto files
const connectorsContent = await Bun.file(
  resolve(projectRoot, connectorsProtoFile)
).text();
const primitivesContent = await Bun.file(
  resolve(projectRoot, primitivesProtoFile)
).text();

// Parse enum from proto content
function parseEnum(content: string, enumName: string): EnumInfo {
  const info: EnumInfo = { name: enumName, values: [] };

  const enumPattern = new RegExp(
    `enum\\s+${enumName}\\s*\\{([^}]+)\\}`,
    "s"
  );
  const match = content.match(enumPattern);
  if (!match?.[1]) return info;

  const enumBody = match[1];
  const valuePattern = /(\w+)\s*=\s*\d+\s*;?\s*(?:\/\/\s*(.+))?/g;
  let valueMatch: RegExpExecArray | null;

  while ((valueMatch = valuePattern.exec(enumBody)) !== null) {
    const protoName = valueMatch[1];
    if (protoName.includes("UNSPECIFIED")) continue;

    // Convert CONNECTOR_POSTGRES -> postgres
    const prefix = enumName.toUpperCase() + "_";
    let stringVal = protoName;
    if (stringVal.startsWith(prefix)) {
      stringVal = stringVal.slice(prefix.length);
    }
    stringVal = stringVal.toLowerCase();

    info.values.push({ protoName, stringVal });
  }

  // Sort by string value for consistent output
  info.values.sort((a, b) => a.stringVal.localeCompare(b.stringVal));

  return info;
}

// Convert string to Go constant name: "postgres" -> "ConnectorPostgres"
function toGoConstantName(val: string, prefix: string): string {
  if (!val) return prefix;
  return prefix + val.charAt(0).toUpperCase() + val.slice(1);
}

// Generate connectors.go content
function generateConnectorsFile(enumInfo: EnumInfo): string {
  let buf = "";

  buf += "// Code generated by scripts/generate-types.ts. DO NOT EDIT.\n";
  buf += "// Source: proto/connectors/connectors.proto\n\n";
  buf += "package types\n\n";
  buf += "import (\n";
  buf += '\t"fmt"\n\n';
  buf += '\t"github.com/hyperterse/hyperterse/core/proto/connectors"\n';
  buf += ")\n\n";

  // Type definition
  buf += "// ConnectorType represents the allowed connector types\n";
  buf += "type ConnectorType string\n\n";

  // Constants
  buf += "const (\n";
  for (const val of enumInfo.values) {
    const constName = toGoConstantName(val.stringVal, "Connector");
    buf += `\t${constName} ConnectorType = "${val.stringVal}"\n`;
  }
  buf += ")\n\n";

  // ValidConnectors map
  buf += "// ValidConnectors is a map of all valid connector type strings\n";
  buf += "var ValidConnectors = map[string]bool{\n";
  for (const val of enumInfo.values) {
    const constName = toGoConstantName(val.stringVal, "Connector");
    buf += `\tstring(${constName}): true,\n`;
  }
  buf += "}\n\n";

  // IsValidConnectorType function
  buf +=
    "// IsValidConnectorType checks if the given string is a valid connector type\n";
  buf += "func IsValidConnectorType(t string) bool {\n";
  buf += "\treturn ValidConnectors[t]\n";
  buf += "}\n\n";

  // GetValidConnectors function
  buf +=
    "// GetValidConnectors returns a slice of all valid connector type strings\n";
  buf += "func GetValidConnectors() []string {\n";
  buf += "\treturn []string{\n";
  for (const val of enumInfo.values) {
    const constName = toGoConstantName(val.stringVal, "Connector");
    buf += `\t\tstring(${constName}),\n`;
  }
  buf += "\t}\n";
  buf += "}\n\n";

  // StringToConnectorEnum function
  buf +=
    "// StringToConnectorEnum converts a string connector name to the protobuf Connector enum.\n";
  buf +=
    "// Returns an error if the string is not a valid connector type.\n";
  buf +=
    "func StringToConnectorEnum(s string) (connectors.Connector, error) {\n";
  buf += "\tswitch s {\n";
  for (const val of enumInfo.values) {
    const constName = toGoConstantName(val.stringVal, "Connector");
    const protoConstName = `connectors.Connector_${val.protoName}`;
    buf += `\tcase string(${constName}):\n`;
    buf += `\t\treturn ${protoConstName}, nil\n`;
  }
  buf += "\tdefault:\n";
  buf +=
    '\t\treturn connectors.Connector_CONNECTOR_UNSPECIFIED, fmt.Errorf("invalid connector type: %s", s)\n';
  buf += "\t}\n";
  buf += "}\n";

  return buf;
}

// Generate primitives.go content
function generatePrimitivesFile(enumInfo: EnumInfo): string {
  let buf = "";

  buf += "// Code generated by scripts/generate-types.ts. DO NOT EDIT.\n";
  buf += "// Source: proto/primitives/primitives.proto\n\n";
  buf += "package types\n\n";
  buf += "import (\n";
  buf += '\t"fmt"\n\n';
  buf += '\t"github.com/hyperterse/hyperterse/core/proto/primitives"\n';
  buf += ")\n\n";

  // Type definition
  buf += "// PrimitiveType represents the allowed primitive types\n";
  buf += "type PrimitiveType string\n\n";

  // Constants
  buf += "const (\n";
  for (const val of enumInfo.values) {
    const constName = toGoConstantName(val.stringVal, "Primitive");
    buf += `\t${constName} PrimitiveType = "${val.stringVal}"\n`;
  }
  buf += ")\n\n";

  // ValidPrimitives map
  buf += "// ValidPrimitives is a map of all valid primitive type strings\n";
  buf += "var ValidPrimitives = map[string]bool{\n";
  for (const val of enumInfo.values) {
    const constName = toGoConstantName(val.stringVal, "Primitive");
    buf += `\tstring(${constName}): true,\n`;
  }
  buf += "}\n\n";

  // IsValidPrimitiveType function
  buf +=
    "// IsValidPrimitiveType checks if the given string is a valid primitive type\n";
  buf += "func IsValidPrimitiveType(t string) bool {\n";
  buf += "\treturn ValidPrimitives[t]\n";
  buf += "}\n\n";

  // GetValidPrimitives function
  buf +=
    "// GetValidPrimitives returns a slice of all valid primitive type strings\n";
  buf += "func GetValidPrimitives() []string {\n";
  buf += "\treturn []string{\n";
  for (const val of enumInfo.values) {
    const constName = toGoConstantName(val.stringVal, "Primitive");
    buf += `\t\tstring(${constName}),\n`;
  }
  buf += "\t}\n";
  buf += "}\n\n";

  // StringToPrimitiveEnum function
  buf +=
    "// StringToPrimitiveEnum converts a string primitive name to the protobuf Primitive enum.\n";
  buf +=
    "// Returns an error if the string is not a valid primitive type.\n";
  buf +=
    "func StringToPrimitiveEnum(s string) (primitives.Primitive, error) {\n";
  buf += "\tswitch s {\n";
  for (const val of enumInfo.values) {
    const constName = toGoConstantName(val.stringVal, "Primitive");
    const protoConstName = `primitives.Primitive_${val.protoName}`;
    buf += `\tcase string(${constName}):\n`;
    buf += `\t\treturn ${protoConstName}, nil\n`;
  }
  buf += "\tdefault:\n";
  buf +=
    '\t\treturn primitives.Primitive_PRIMITIVE_UNSPECIFIED, fmt.Errorf("invalid primitive type: %s", s)\n';
  buf += "\t}\n";
  buf += "}\n\n";

  // PrimitiveEnumToString function
  buf +=
    "// PrimitiveEnumToString converts a protobuf Primitive enum to its string representation.\n";
  buf +=
    '// e.g., PRIMITIVE_STRING -> "string", PRIMITIVE_INT -> "int"\n';
  buf += "func PrimitiveEnumToString(p primitives.Primitive) string {\n";
  buf += "\tswitch p {\n";
  for (const val of enumInfo.values) {
    const protoConstName = `primitives.Primitive_${val.protoName}`;
    buf += `\tcase ${protoConstName}:\n`;
    buf += `\t\treturn "${val.stringVal}"\n`;
  }
  buf += "\tdefault:\n";
  buf += '\t\treturn ""\n';
  buf += "\t}\n";
  buf += "}\n";

  return buf;
}

// Parse enums
const connectorEnum = parseEnum(connectorsContent, "Connector");
const primitiveEnum = parseEnum(primitivesContent, "Primitive");

// Ensure output directory exists
mkdirSync(resolve(projectRoot, "core", "types"), { recursive: true });

// Generate and write connectors.go
const connectorsPath = resolve(projectRoot, "core", "types", "connectors.go");
await Bun.write(connectorsPath, generateConnectorsFile(connectorEnum));

// Generate and write primitives.go
const primitivesPath = resolve(projectRoot, "core", "types", "primitives.go");
await Bun.write(primitivesPath, generatePrimitivesFile(primitiveEnum));

// Format with gofmt
await $`gofmt -w ${connectorsPath} ${primitivesPath}`;

console.log("Successfully generated connectors.go and primitives.go");
