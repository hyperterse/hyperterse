//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// EnumInfo represents information about a proto enum
type EnumInfo struct {
	Name      string
	Values    []EnumValue
	StringMap map[string]string // Maps proto enum name to string value
}

// EnumValue represents a single enum value
type EnumValue struct {
	ProtoName string // e.g., "CONNECTOR_POSTGRES"
	StringVal string // e.g., "postgres"
}

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s <connectors-proto-file> <primitives-proto-file>\n", os.Args[0])
		os.Exit(1)
	}

	connectorsProtoFile := os.Args[1]
	primitivesProtoFile := os.Args[2]

	// Read connectors proto file
	connectorsContent, err := os.ReadFile(connectorsProtoFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading connectors proto file: %v\n", err)
		os.Exit(1)
	}

	// Read primitives proto file
	primitivesContent, err := os.ReadFile(primitivesProtoFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading primitives proto file: %v\n", err)
		os.Exit(1)
	}

	// Parse enums from proto files
	connectorEnum := parseEnum(connectorsContent, "Connector")
	primitiveEnum := parseEnum(primitivesContent, "Primitive")

	// Generate connectors.go
	if err := generateConnectorsFile(connectorEnum); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating connectors.go: %v\n", err)
		os.Exit(1)
	}

	// Generate primitives.go
	if err := generatePrimitivesFile(primitiveEnum); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating primitives.go: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Successfully generated connectors.go and primitives.go")
}

// parseEnum extracts enum information from proto file content
func parseEnum(content []byte, enumName string) EnumInfo {
	enumInfo := EnumInfo{
		Name:      enumName,
		Values:    []EnumValue{},
		StringMap: make(map[string]string),
	}

	// Pattern to match enum definition (handles multi-line)
	// enum Connector { CONNECTOR_POSTGRES = 1; ... }
	enumPattern := regexp.MustCompile(fmt.Sprintf(`enum\s+%s\s*\{([^}]+)\}`, enumName))
	matches := enumPattern.FindSubmatch(content)
	if len(matches) < 2 {
		// Try with multiline flag
		enumPattern = regexp.MustCompile(fmt.Sprintf(`(?s)enum\s+%s\s*\{([^}]+)\}`, enumName))
		matches = enumPattern.FindSubmatch(content)
		if len(matches) < 2 {
			return enumInfo
		}
	}

	enumBody := string(matches[1])

	// Pattern to match enum values: CONNECTOR_POSTGRES = 1; // comment
	valuePattern := regexp.MustCompile(`(\w+)\s*=\s*\d+\s*;?\s*(?://\s*(.+))?`)
	valueMatches := valuePattern.FindAllStringSubmatch(enumBody, -1)

	for _, match := range valueMatches {
		if len(match) < 2 {
			continue
		}

		protoName := match[1]
		// Skip UNSPECIFIED values
		if strings.Contains(protoName, "UNSPECIFIED") {
			continue
		}

		// Convert CONNECTOR_POSTGRES -> postgres
		// Convert PRIMITIVE_STRING -> string
		stringVal := convertProtoEnumToString(protoName, enumName)

		enumInfo.Values = append(enumInfo.Values, EnumValue{
			ProtoName: protoName,
			StringVal: stringVal,
		})
		enumInfo.StringMap[protoName] = stringVal
	}

	// Sort values for consistent output
	sort.Slice(enumInfo.Values, func(i, j int) bool {
		return enumInfo.Values[i].StringVal < enumInfo.Values[j].StringVal
	})

	return enumInfo
}

// convertProtoEnumToString converts proto enum names to their string representations
func convertProtoEnumToString(protoName, enumName string) string {
	// Remove enum prefix: CONNECTOR_POSTGRES -> POSTGRES, PRIMITIVE_STRING -> STRING
	prefix := strings.ToUpper(enumName) + "_"
	if strings.HasPrefix(protoName, prefix) {
		protoName = strings.TrimPrefix(protoName, prefix)
	}

	// Convert to lowercase: POSTGRES -> postgres
	return strings.ToLower(protoName)
}

// generateConnectorsFile generates core/types/connectors.go
func generateConnectorsFile(enum EnumInfo) error {
	var buf strings.Builder

	buf.WriteString("// Code generated by scripts/generate_types/script.go. DO NOT EDIT.\n")
	buf.WriteString("// Source: proto/connectors.proto\n\n")
	buf.WriteString("package types\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"fmt\"\n\n")
	buf.WriteString("\t\"github.com/hyperterse/hyperterse/core/pb\"\n")
	buf.WriteString(")\n\n")

	// Type definition
	buf.WriteString("// ConnectorType represents the allowed connector types\n")
	buf.WriteString("type ConnectorType string\n\n")

	// Constants
	buf.WriteString("const (\n")
	for _, val := range enum.Values {
		constName := toGoConstantName(val.StringVal, "Connector")
		buf.WriteString(fmt.Sprintf("\t%s ConnectorType = %q\n", constName, val.StringVal))
	}
	buf.WriteString(")\n\n")

	// ValidConnectors map
	buf.WriteString("// ValidConnectors is a map of all valid connector type strings\n")
	buf.WriteString("var ValidConnectors = map[string]bool{\n")
	for _, val := range enum.Values {
		constName := toGoConstantName(val.StringVal, "Connector")
		buf.WriteString(fmt.Sprintf("\tstring(%s): true,\n", constName))
	}
	buf.WriteString("}\n\n")

	// IsValidConnectorType function
	buf.WriteString("// IsValidConnectorType checks if the given string is a valid connector type\n")
	buf.WriteString("func IsValidConnectorType(t string) bool {\n")
	buf.WriteString("\treturn ValidConnectors[t]\n")
	buf.WriteString("}\n\n")

	// GetValidConnectors function
	buf.WriteString("// GetValidConnectors returns a slice of all valid connector type strings\n")
	buf.WriteString("func GetValidConnectors() []string {\n")
	buf.WriteString("\treturn []string{\n")
	for _, val := range enum.Values {
		constName := toGoConstantName(val.StringVal, "Connector")
		buf.WriteString(fmt.Sprintf("\t\tstring(%s),\n", constName))
	}
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// StringToConnectorEnum function
	buf.WriteString("// StringToConnectorEnum converts a string connector name to the protobuf Connector enum.\n")
	buf.WriteString("// Returns an error if the string is not a valid connector type.\n")
	buf.WriteString("func StringToConnectorEnum(s string) (pb.Connector, error) {\n")
	buf.WriteString("\tswitch s {\n")
	for _, val := range enum.Values {
		constName := toGoConstantName(val.StringVal, "Connector")
		protoConstName := fmt.Sprintf("pb.Connector_%s", val.ProtoName)
		buf.WriteString(fmt.Sprintf("\tcase string(%s):\n", constName))
		buf.WriteString(fmt.Sprintf("\t\treturn %s, nil\n", protoConstName))
	}
	buf.WriteString("\tdefault:\n")
	buf.WriteString("\t\treturn pb.Connector_CONNECTOR_UNSPECIFIED, fmt.Errorf(\"invalid connector type: %s\", s)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n")

	// Format and write file
	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return fmt.Errorf("error formatting code: %w", err)
	}

	outputPath := filepath.Join("core", "types", "connectors.go")
	return os.WriteFile(outputPath, formatted, 0644)
}

// generatePrimitivesFile generates core/types/primitives.go
func generatePrimitivesFile(enum EnumInfo) error {
	var buf strings.Builder

	buf.WriteString("// Code generated by scripts/generate_types/script.go. DO NOT EDIT.\n")
	buf.WriteString("// Source: proto/primitives.proto\n\n")
	buf.WriteString("package types\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"fmt\"\n\n")
	buf.WriteString("\t\"github.com/hyperterse/hyperterse/core/pb\"\n")
	buf.WriteString(")\n\n")

	// Type definition
	buf.WriteString("// PrimitiveType represents the allowed primitive types\n")
	buf.WriteString("type PrimitiveType string\n\n")

	// Constants
	buf.WriteString("const (\n")
	for _, val := range enum.Values {
		constName := toGoConstantName(val.StringVal, "Primitive")
		buf.WriteString(fmt.Sprintf("\t%s PrimitiveType = %q\n", constName, val.StringVal))
	}
	buf.WriteString(")\n\n")

	// ValidPrimitives map
	buf.WriteString("// ValidPrimitives is a map of all valid primitive type strings\n")
	buf.WriteString("var ValidPrimitives = map[string]bool{\n")
	for _, val := range enum.Values {
		constName := toGoConstantName(val.StringVal, "Primitive")
		buf.WriteString(fmt.Sprintf("\tstring(%s): true,\n", constName))
	}
	buf.WriteString("}\n\n")

	// IsValidPrimitiveType function
	buf.WriteString("// IsValidPrimitiveType checks if the given string is a valid primitive type\n")
	buf.WriteString("func IsValidPrimitiveType(t string) bool {\n")
	buf.WriteString("\treturn ValidPrimitives[t]\n")
	buf.WriteString("}\n\n")

	// GetValidPrimitives function
	buf.WriteString("// GetValidPrimitives returns a slice of all valid primitive type strings\n")
	buf.WriteString("func GetValidPrimitives() []string {\n")
	buf.WriteString("\treturn []string{\n")
	for _, val := range enum.Values {
		constName := toGoConstantName(val.StringVal, "Primitive")
		buf.WriteString(fmt.Sprintf("\t\tstring(%s),\n", constName))
	}
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// StringToPrimitiveEnum function
	buf.WriteString("// StringToPrimitiveEnum converts a string primitive name to the protobuf Primitive enum.\n")
	buf.WriteString("// Returns an error if the string is not a valid primitive type.\n")
	buf.WriteString("func StringToPrimitiveEnum(s string) (pb.Primitive, error) {\n")
	buf.WriteString("\tswitch s {\n")
	for _, val := range enum.Values {
		constName := toGoConstantName(val.StringVal, "Primitive")
		protoConstName := fmt.Sprintf("pb.Primitive_%s", val.ProtoName)
		buf.WriteString(fmt.Sprintf("\tcase string(%s):\n", constName))
		buf.WriteString(fmt.Sprintf("\t\treturn %s, nil\n", protoConstName))
	}
	buf.WriteString("\tdefault:\n")
	buf.WriteString("\t\treturn pb.Primitive_PRIMITIVE_UNSPECIFIED, fmt.Errorf(\"invalid primitive type: %s\", s)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n")

	// Format and write file
	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return fmt.Errorf("error formatting code: %w", err)
	}

	outputPath := filepath.Join("core", "types", "primitives.go")
	return os.WriteFile(outputPath, formatted, 0644)
}

// toGoConstantName converts a string value to a Go constant name
// e.g., "postgres" -> "ConnectorPostgres", "string" -> "PrimitiveString"
func toGoConstantName(val, prefix string) string {
	// Capitalize first letter
	if len(val) == 0 {
		return prefix
	}
	return prefix + strings.ToUpper(val[:1]) + val[1:]
}
