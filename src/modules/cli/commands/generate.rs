//! Generate command implementation

use clap::{Args, Subcommand};
use hyperterse_core::HyperterseError;
use hyperterse_parser::parse_file;
use std::fs;
use std::path::Path;
use tracing::info;

/// Generate command arguments
#[derive(Args, Debug)]
pub struct GenerateCommand {
    #[command(subcommand)]
    pub command: GenerateSubcommand,
}

/// Generate subcommands
#[derive(Subcommand, Debug)]
pub enum GenerateSubcommand {
    /// Generate LLM documentation (llms.txt)
    Llms(GenerateLlmsArgs),

    /// Generate MCP skills documentation
    Skills(GenerateSkillsArgs),

    /// Generate OpenAPI specification
    Openapi(GenerateOpenapiArgs),
}

/// Arguments for llms generation
#[derive(Args, Debug)]
pub struct GenerateLlmsArgs {
    /// Output file path
    #[arg(short, long, default_value = "llms.txt")]
    pub output: String,
}

/// Arguments for skills generation
#[derive(Args, Debug)]
pub struct GenerateSkillsArgs {
    /// Output file path
    #[arg(short, long, default_value = "skills.md")]
    pub output: String,
}

/// Arguments for OpenAPI generation
#[derive(Args, Debug)]
pub struct GenerateOpenapiArgs {
    /// Output file path
    #[arg(short, long, default_value = "openapi.json")]
    pub output: String,
}

impl GenerateCommand {
    /// Execute the generate command
    pub async fn execute(&self, config_path: &str) -> Result<(), HyperterseError> {
        let model = parse_file(config_path)?;

        match &self.command {
            GenerateSubcommand::Llms(args) => {
                Self::generate_llms(&model, &args.output)?;
            }
            GenerateSubcommand::Skills(args) => {
                Self::generate_skills(&model, &args.output)?;
            }
            GenerateSubcommand::Openapi(args) => {
                Self::generate_openapi(&model, &args.output)?;
            }
        }

        Ok(())
    }

    /// Generate LLM documentation
    fn generate_llms(model: &hyperterse_core::Model, output: &str) -> Result<(), HyperterseError> {
        info!("Generating LLM documentation to: {}", output);

        let mut content = String::new();

        // Header
        content.push_str(&format!("# {}\n\n", model.name));
        content.push_str(&format!(
            "> API documentation for {} generated by Hyperterse\n\n",
            model.name
        ));

        // Overview
        content.push_str("## Overview\n\n");
        content.push_str(&format!(
            "This API provides {} query endpoint(s) for database operations.\n\n",
            model.queries.len()
        ));

        // Base URL
        content.push_str("## Base URL\n\n");
        content.push_str("```\n");
        content.push_str(&format!("http://localhost:{}\n", model.port()));
        content.push_str("```\n\n");

        // Queries
        if !model.queries.is_empty() {
            content.push_str("## Queries\n\n");

            for query in &model.queries {
                content.push_str(&format!("### {}\n\n", query.name));

                if let Some(desc) = &query.description {
                    content.push_str(&format!("{}\n\n", desc));
                }

                content.push_str("**Endpoint:**\n```\n");
                content.push_str(&format!("POST /query/{}\n", query.name));
                content.push_str("```\n\n");

                if !query.inputs.is_empty() {
                    content.push_str("**Inputs:**\n\n");
                    content.push_str("| Name | Type | Required | Description |\n");
                    content.push_str("|------|------|----------|-------------|\n");

                    for input in &query.inputs {
                        let required = if input.required { "Yes" } else { "No" };
                        let description = input.description.as_deref().unwrap_or("-");
                        content.push_str(&format!(
                            "| {} | {} | {} | {} |\n",
                            input.name, input.primitive_type, required, description
                        ));
                    }
                    content.push_str("\n");
                }
            }
        }

        // Write to file
        let path = Path::new(output);
        if let Some(parent) = path.parent() {
            if !parent.as_os_str().is_empty() {
                fs::create_dir_all(parent)?;
            }
        }

        fs::write(output, content)?;

        info!("Generated: {}", output);
        Ok(())
    }

    /// Generate MCP skills documentation
    fn generate_skills(
        model: &hyperterse_core::Model,
        output: &str,
    ) -> Result<(), HyperterseError> {
        info!("Generating MCP skills documentation to: {}", output);

        let mut content = String::new();

        // Header
        content.push_str(&format!("# {} Skills\n\n", model.name));
        content.push_str("MCP tool definitions for AI assistants.\n\n");

        // Tools section
        content.push_str("## Available Tools\n\n");

        for query in &model.queries {
            content.push_str(&format!("### {}\n\n", query.name));

            if let Some(desc) = &query.description {
                content.push_str(&format!("{}\n\n", desc));
            }

            content.push_str("**Parameters:**\n\n");

            if query.inputs.is_empty() {
                content.push_str("No parameters required.\n\n");
            } else {
                content.push_str("```json\n");
                let schema = Self::build_json_schema(&query.inputs);
                content.push_str(&serde_json::to_string_pretty(&schema).unwrap_or_default());
                content.push_str("\n```\n\n");
            }
        }

        // Write to file
        let path = Path::new(output);
        if let Some(parent) = path.parent() {
            if !parent.as_os_str().is_empty() {
                fs::create_dir_all(parent)?;
            }
        }

        fs::write(output, content)?;

        info!("Generated: {}", output);
        Ok(())
    }

    /// Generate OpenAPI specification
    fn generate_openapi(
        model: &hyperterse_core::Model,
        output: &str,
    ) -> Result<(), HyperterseError> {
        info!("Generating OpenAPI specification to: {}", output);

        let spec = hyperterse_runtime::handlers::OpenApiHandler::generate_spec_static(model);

        // Write to file
        let path = Path::new(output);
        if let Some(parent) = path.parent() {
            if !parent.as_os_str().is_empty() {
                fs::create_dir_all(parent)?;
            }
        }

        fs::write(
            output,
            serde_json::to_string_pretty(&spec).unwrap_or_default(),
        )?;

        info!("Generated: {}", output);
        Ok(())
    }

    /// Build JSON schema for inputs
    fn build_json_schema(inputs: &[hyperterse_core::Input]) -> serde_json::Value {
        let mut properties = serde_json::Map::new();
        let mut required = Vec::new();

        for input in inputs {
            let type_str = match input.primitive_type {
                hyperterse_types::Primitive::String => "string",
                hyperterse_types::Primitive::Int => "integer",
                hyperterse_types::Primitive::Float => "number",
                hyperterse_types::Primitive::Boolean => "boolean",
                hyperterse_types::Primitive::Uuid => "string",
                hyperterse_types::Primitive::Datetime => "string",
            };

            let mut prop = serde_json::Map::new();
            prop.insert("type".to_string(), serde_json::json!(type_str));
            if let Some(desc) = &input.description {
                prop.insert("description".to_string(), serde_json::json!(desc));
            }

            properties.insert(input.name.clone(), serde_json::Value::Object(prop));

            if input.required {
                required.push(input.name.clone());
            }
        }

        serde_json::json!({
            "type": "object",
            "properties": properties,
            "required": required
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use hyperterse_core::Input;
    use hyperterse_types::Primitive;
    use serde_json::json;

    #[test]
    fn test_build_json_schema() {
        let inputs = vec![
            Input::new("id", Primitive::Int),
            Input::optional("name", Primitive::String, json!("")),
        ];

        let schema = GenerateCommand::build_json_schema(&inputs);
        assert_eq!(schema["type"], "object");
        assert!(schema["properties"]["id"].is_object());
        assert!(schema["properties"]["name"].is_object());
    }
}
