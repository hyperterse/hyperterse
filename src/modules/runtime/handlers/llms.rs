//! LLM documentation handler

use axum::{
    extract::State,
    http::{header, StatusCode},
    response::IntoResponse,
};

use crate::state::AppState;

/// Handler for LLM documentation
pub struct LlmsHandler;

impl LlmsHandler {
    /// Handle GET /llms.txt
    pub async fn handle(State(state): State<AppState>) -> impl IntoResponse {
        let model = state.executor.model();
        let content = Self::generate_llms_txt(model);

        (
            StatusCode::OK,
            [(header::CONTENT_TYPE, "text/plain; charset=utf-8")],
            content,
        )
    }

    /// Generate llms.txt documentation
    fn generate_llms_txt(model: &hyperterse_core::Model) -> String {
        let mut lines = Vec::new();

        // Header
        lines.push(format!("# {}", model.name));
        lines.push(String::new());
        lines.push(format!(
            "> API documentation for {} generated by Hyperterse",
            model.name
        ));
        lines.push(String::new());

        // Overview
        lines.push("## Overview".to_string());
        lines.push(String::new());
        lines.push(format!(
            "This API provides {} query endpoint(s) for database operations.",
            model.queries.len()
        ));
        lines.push(String::new());

        // Base URL
        lines.push("## Base URL".to_string());
        lines.push(String::new());
        lines.push("```".to_string());
        lines.push(format!("http://localhost:{}", model.port()));
        lines.push("```".to_string());
        lines.push(String::new());

        // Queries section
        if !model.queries.is_empty() {
            lines.push("## Queries".to_string());
            lines.push(String::new());

            for query in &model.queries {
                // Query header
                lines.push(format!("### {}", query.name));
                lines.push(String::new());

                // Description
                if let Some(desc) = &query.description {
                    lines.push(desc.clone());
                    lines.push(String::new());
                }

                // Endpoint
                lines.push("**Endpoint:**".to_string());
                lines.push("```".to_string());
                lines.push(format!("POST /query/{}", query.name));
                lines.push("```".to_string());
                lines.push(String::new());

                // Inputs
                if !query.inputs.is_empty() {
                    lines.push("**Inputs:**".to_string());
                    lines.push(String::new());
                    lines.push("| Name | Type | Required | Description |".to_string());
                    lines.push("|------|------|----------|-------------|".to_string());

                    for input in &query.inputs {
                        let required = if input.required { "Yes" } else { "No" };
                        let description = input.description.as_deref().unwrap_or("-");
                        let default_note = if let Some(default) = &input.default {
                            format!(" (default: {})", default)
                        } else {
                            String::new()
                        };

                        lines.push(format!(
                            "| {} | {} | {} | {}{} |",
                            input.name, input.primitive_type, required, description, default_note
                        ));
                    }
                    lines.push(String::new());
                }

                // Example request
                lines.push("**Example Request:**".to_string());
                lines.push("```json".to_string());
                let example_inputs = Self::generate_example_inputs(&query.inputs);
                lines.push(serde_json::to_string_pretty(&serde_json::json!({
                        "inputs": example_inputs
                    }))
                    .unwrap_or_default().to_string());
                lines.push("```".to_string());
                lines.push(String::new());

                // Example response
                lines.push("**Example Response:**".to_string());
                lines.push("```json".to_string());
                lines.push(serde_json::to_string_pretty(&serde_json::json!({
                        "success": true,
                        "error": "",
                        "results": []
                    }))
                    .unwrap_or_default().to_string());
                lines.push("```".to_string());
                lines.push(String::new());
            }
        }

        // Response format
        lines.push("## Response Format".to_string());
        lines.push(String::new());
        lines.push("All query responses follow this format:".to_string());
        lines.push(String::new());
        lines.push("```json".to_string());
        lines.push(serde_json::to_string_pretty(&serde_json::json!({
                "success": true,
                "error": "Error message (empty on success)",
                "results": [{"column1": "value1", "column2": "value2"}]
            }))
            .unwrap_or_default().to_string());
        lines.push("```".to_string());
        lines.push(String::new());

        // Error handling
        lines.push("## Error Handling".to_string());
        lines.push(String::new());
        lines.push("When an error occurs, `success` will be `false` and `error` will contain a description of the problem.".to_string());
        lines.push(String::new());
        lines.push("Common HTTP status codes:".to_string());
        lines.push("- **200**: Success".to_string());
        lines.push("- **400**: Bad Request (validation error)".to_string());
        lines.push("- **404**: Query not found".to_string());
        lines.push("- **500**: Internal server error".to_string());
        lines.push(String::new());

        // Footer
        lines.push("---".to_string());
        lines.push(
            "Generated by [Hyperterse](https://github.com/hyperterse/hyperterse)".to_string(),
        );

        lines.join("\n")
    }

    /// Generate example input values
    fn generate_example_inputs(inputs: &[hyperterse_core::Input]) -> serde_json::Value {
        let mut map = serde_json::Map::new();

        for input in inputs {
            let value = match input.primitive_type {
                hyperterse_types::Primitive::String => serde_json::json!("example"),
                hyperterse_types::Primitive::Int => serde_json::json!(1),
                hyperterse_types::Primitive::Float => serde_json::json!(1.0),
                hyperterse_types::Primitive::Boolean => serde_json::json!(true),
                hyperterse_types::Primitive::Uuid => {
                    serde_json::json!("00000000-0000-0000-0000-000000000000")
                }
                hyperterse_types::Primitive::Datetime => {
                    serde_json::json!("2024-01-01T00:00:00Z")
                }
            };
            map.insert(input.name.clone(), value);
        }

        serde_json::Value::Object(map)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use hyperterse_core::{Adapter, Input, Model, Query};
    use hyperterse_types::{Connector, Primitive};

    fn create_test_model() -> Model {
        Model {
            name: "test-api".to_string(),
            adapters: vec![Adapter::new(
                "db",
                Connector::Postgres,
                "postgres://localhost/test",
            )],
            queries: vec![Query::new(
                "get-user",
                "db",
                "SELECT * FROM users WHERE id = {{ inputs.id }}",
            )
            .with_description("Get a user by ID")
            .with_input(Input::new("id", Primitive::Int))],
            server: None,
            export: None,
        }
    }

    #[test]
    fn test_generate_llms_txt() {
        let model = create_test_model();
        let content = LlmsHandler::generate_llms_txt(&model);

        assert!(content.contains("# test-api"));
        assert!(content.contains("### get-user"));
        assert!(content.contains("POST /query/get-user"));
        assert!(content.contains("| id | int | Yes |"));
    }
}
