---
title: Introduction
description: Build MCP tool servers from declarative configuration with built-in authentication, caching, and observability.
icon: "book-open"
---

Every AI agent that queries a database, calls an API, or runs business logic needs the same infrastructure: connection management, input validation, authentication, caching, observability, and a transport protocol that LLMs understand.

With Hyperterse, you define your tools in YAML configuration files. The framework compiles, validates, bundles, and serves them as a standards-compliant [MCP](https://modelcontextprotocol.io/) server. You own the data and the logic — the framework handles everything else.

## What you can build

You use Hyperterse to expose databases and custom logic as MCP tools that any AI agent can call. A typical route looks like this:

```yaml app/routes/get-user/config.terse
description: "Get user by ID"
use: primary-db
statement: "SELECT id, name, email FROM users WHERE id = {{ inputs.user_id }}"
inputs:
  user_id:
    type: int
    required: true
auth:
  plugin: api_key
  policy:
    value: "{{ env.API_KEY }}"
```

This configuration creates an MCP tool called `get-user` that queries your database, validates inputs, and enforces API key authentication — without writing any application code.

## How it works

<Steps>
  <Step title="Define your tools">
    Create `.terse` YAML files for your database connections and routes. Each directory under `app/routes/` becomes one MCP tool.
  </Step>
  <Step title="Compile your project">
    Run `hyperterse build` to validate configuration, bundle scripts, and serialize everything into a single deployable artifact.
  </Step>
  <Step title="Serve your MCP server">
    Run `hyperterse serve` to boot from the compiled artifact. Your tools are immediately available at `/mcp` over Streamable HTTP.
  </Step>
</Steps>

<Tip>
During development, run `hyperterse start --watch` to skip the separate build step. The framework recompiles automatically on every file change.
</Tip>

<Frame caption="Compile-time validation flows into a production-ready runtime">
  <img src="/assets/diagrams/lifecycle.svg" alt="Hyperterse lifecycle: compile-time steps flow into runtime initialization" />
</Frame>

## Key capabilities

<CardGroup cols={2}>
  <Card title="Database adapters" icon="database" href="/concepts/adapters">
    Connect to PostgreSQL, MySQL, MongoDB, or Redis. Define connection strings in `app/adapters/` — the framework manages pooling, health checks, and shutdown.
  </Card>
  <Card title="Filesystem-based routing" icon="folder-tree" href="/concepts/routes-and-tools">
    Each folder under `app/routes/` maps to one MCP tool. No manual registration — the directory name becomes the tool name.
  </Card>
  <Card title="Embedded scripting" icon="code" href="/concepts/scripts">
    Add TypeScript handlers and transforms when you need logic that configuration alone cannot express. Scripts run in a sandboxed runtime with `fetch` and `console`.
  </Card>
  <Card title="Per-route authentication" icon="lock" href="/concepts/authentication">
    Attach authentication to any route with a built-in `api_key` plugin, or write your own. No global middleware to configure.
  </Card>
  <Card title="In-memory caching" icon="bolt" href="/runtime/caching">
    Enable query result caching globally or per-route with a TTL. Identical requests return cached results without hitting your database.
  </Card>
  <Card title="Observability" icon="chart-line" href="/runtime/observability">
    Built-in OpenTelemetry support gives you distributed tracing, metrics, and structured logging out of the box.
  </Card>
</CardGroup>

## Next steps

<CardGroup cols={2}>
  <Card title="Install the CLI" icon="download" href="/getting-started/installation">
    Set up Hyperterse on your machine in under a minute.
  </Card>
  <Card title="Build your first tool server" icon="rocket" href="/getting-started/quickstart">
    Scaffold a project and serve your first MCP tool in under five minutes.
  </Card>
</CardGroup>
