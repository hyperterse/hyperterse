---
title: Architecture
description: System design, component boundaries, and data flow within the Hyperterse runtime.
---

## Component Overview

Hyperterse is structured as a pipeline of compilation and execution phases. Each component has a well-defined boundary and communicates through protobuf-defined data structures.

```
┌─────────────────────────────────────────────────────────────────┐
│                        CLI Layer                                │
│  start · serve · build · validate · init · upgrade              │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Parser Layer                                │
│  YAML parser · DSL parser · Model validator                     │
│  Input: .hyperterse, .terse files                               │
│  Output: hyperterse.Model (protobuf)                            │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                   Framework Layer                               │
│  Compiler · Bundler · Manifest builder · Engine · Auth registry │
│  Input: Model + app/ filesystem                                 │
│  Output: Project (routes, adapters, bundles) + FrameworkManifest│
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Runtime Layer                                │
│  HTTP server · MCP adapter · Executor · Connector manager       │
│  JS runtime (Goja) · Cache (Ristretto) · Observability          │
│  Input: Project or model.bin manifest                           │
│  Output: MCP tool responses                                     │
└─────────────────────────────────────────────────────────────────┘
```

---

## Data Model

All configuration flows through a single intermediate representation defined in `proto/hyperterse/hyperterse.proto`:

**`hyperterse.Model`** — The root container. Holds service metadata, adapter definitions, query/tool definitions, server configuration, build configuration, and the framework manifest.

**`hyperterse.Adapter`** — A named connector binding. Specifies the connector type, connection string, and driver-specific options.

**`hyperterse.Query`** — A tool definition. Contains the tool name, adapter reference (`use`), SQL/command statement, input schema, output schema, cache policy, and optional script bindings.

**`hyperterse.FrameworkManifest`** — Compiled output metadata. Contains the vendor bundle content and per-route bundle manifests with pre-compiled JavaScript.

These structures are serialized to `model.bin` during `hyperterse build` and deserialized during `hyperterse serve`.

---

## Compilation Pipeline

### Step 1: Configuration Parsing

The parser reads `.hyperterse` (root config) and `.terse` (adapter/route configs) as YAML. Each file is parsed into the corresponding protobuf message. Environment variable placeholders (`{{ env.VAR }}`) are preserved as literals at parse time and resolved at runtime.

### Step 2: Framework Compilation

The compiler walks the filesystem to discover adapters and routes:

- `app/adapters/*.terse` — Each file becomes one `Adapter` entry.
- `app/routes/*/config.terse` — Each file becomes one `Query` (tool) entry.

Script references in route configs (`scripts.handler`, `scripts.input_transform`, `scripts.output_transform`) are resolved relative to the route directory.

### Step 3: TypeScript Bundling

The bundler uses esbuild to:

1. Scan all route scripts for external `import` statements.
2. Build shared npm dependencies into a single `vendor.js` bundle.
3. Emit per-route bundles that reference the vendor through `globalThis.__hyperterse_vendor`.

This architecture prevents duplicate dependency code across routes while maintaining isolated route bundles.

### Step 4: Manifest Serialization

The compiled `Model` and `FrameworkManifest` are serialized to `model.bin` using Protocol Buffers binary encoding. The manifest includes all bundle contents inline, making the output directory self-contained.

---

## Execution Pipeline

When a tool is invoked through MCP `tools/call`:

```
MCP Request
    │
    ▼
Route Resolution ─── find compiled route by tool name
    │
    ▼
Auth Plugin ───────── execute configured auth plugin (allow_all, api_key, or custom)
    │
    ▼
Input Transform ───── run inputTransform(payload) if script is bound
    │
    ▼
Execution ─────────── handler script OR connector query
    │                  ├── Handler: run handler(payload) in JS VM
    │                  └── DB: validate → substitute → cache check → execute → cache store
    │
    ▼
Output Transform ──── run outputTransform(payload) if script is bound
    │
    ▼
MCP Response
```

See [Execution Pipeline](/runtime/execution-pipeline) for detailed per-step behavior.

---

## Connector Lifecycle

Connectors are managed through a `ConnectorManager` that handles initialization and shutdown:

- **Initialization** — Connectors start in parallel using `errgroup`. Each connector establishes its connection pool and runs a connectivity check. If any connector fails, the runtime does not start.
- **Execution** — The executor resolves the target connector by adapter name, performs input substitution on the statement, and delegates execution to the connector's `Execute` method.
- **Shutdown** — On `SIGINT` or `SIGTERM`, the connector manager closes all connections concurrently with a configurable timeout.

---

## Script Runtime

Route scripts execute inside an embedded Goja JavaScript VM within the Go process:

- **Isolation** — Each script invocation runs in a fresh VM context loaded with the route bundle and vendor bundle.
- **Built-in APIs** — `fetch` (HTTP client) and `console` (logging) are injected into the global scope.
- **Async support** — `async`/`await` patterns are supported. The Go host polls the event loop to completion before returning results.
- **No filesystem access** — Scripts cannot access the host filesystem, network sockets, or Go internals beyond the injected APIs.

---

## Protobuf Contracts

The system uses four protobuf packages:

| Package | File | Purpose |
|---|---|---|
| `hyperterse` | `proto/hyperterse/hyperterse.proto` | Core model: Model, Adapter, Query, Input, Data, ServerConfig, FrameworkManifest |
| `connectors` | `proto/connectors/connectors.proto` | Connector enum, ConnectorDef, ConnectorConfig |
| `primitives` | `proto/primitives/primitives.proto` | Primitive type enum (string, int, float, boolean, datetime) |
| `runtime` | `proto/runtime/runtime.proto` | RPC service definitions for QueryService and MCPService |

JSON schemas in `schema/` are generated from `connectors.proto` and `primitives.proto` to provide editor-time validation for `.terse` files.

---

## Design Constraints

- **Single-process deployment.** Hyperterse runs as one Go binary. There is no multi-node clustering or distributed state. Scale horizontally by running multiple instances behind a load balancer.
- **In-memory cache only.** The Ristretto cache is process-local. Cache entries are not shared between instances. For distributed caching, use an external cache layer or Redis adapter with custom handler logic.
- **No hot code reload in production.** `--watch` mode is a development feature that restarts the runtime on file changes. Production deployments should use `build` + `serve` with a proper deployment pipeline.
- **Statement substitution is textual.** `{{ inputs.x }}` placeholders are replaced via string substitution before the statement reaches the connector driver. Parameterized queries are the responsibility of the statement author. See [Input Safety](/security/input-safety).
