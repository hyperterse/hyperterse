---
title: Project structure
description: Filesystem conventions and directory layout for Hyperterse projects.
---

Hyperterse uses the filesystem as the source of truth. You define database connections in adapter files and tools in route directories. File names become identifiers. The framework discovers everything from the directory structure — you never register adapters or tools manually.

## Directory layout

A typical project looks like this:

```
project-root/
├── .hyperterse                        # Root service configuration
├── package.json                       # npm dependencies for scripts (optional)
├── app/
│   ├── adapters/
│   │   ├── primary-db.terse           # Adapter: PostgreSQL
│   │   └── cache-store.terse          # Adapter: Redis
│   └── routes/
│       ├── get-user/
│       │   ├── config.terse           # Route configuration
│       │   ├── input-validator.ts     # Input transform script
│       │   └── data-mapper.ts         # Output transform script
│       └── get-weather/
│           ├── config.terse           # Route configuration
│           └── handler.ts             # Custom handler script
```

## Root configuration

The `.hyperterse` file contains service-level settings: name, version, server port, log level, cache defaults, and build options. It does not contain adapter or route definitions — those live in `app/`.

When you run `hyperterse start` or `hyperterse build` without arguments, the CLI looks for `.hyperterse` in the current directory. See [Root configuration reference](/reference/root-config) for the complete field specification.

## Adapter discovery

The compiler scans `app/adapters/*.terse` at build time. Each file defines exactly one adapter. The filename (without extension) becomes the adapter's identifier, unless the file explicitly sets a `name` field.

See [Adapters](/concepts/adapters) for how adapters work, and [Adapter configuration reference](/reference/adapter-config) for the field specification.

## Route discovery

The compiler scans `app/routes/*/config.terse` at build time. Each `config.terse` file defines one MCP tool. The directory name becomes the tool name, unless the file explicitly sets a `name` field.

Every route must define either a database connection (`use`) or a handler script (`scripts.handler`). Routes with neither are rejected during validation.

See [Routes and tools](/concepts/routes-and-tools) for execution models, and [Route configuration reference](/reference/route-config) for the field specification.

## Script resolution

Script paths in route configs are resolved relative to the route directory. You can declare them explicitly, or rely on convention-based discovery where files matching naming patterns (like `*handler*.ts`) are automatically picked up.

See [Scripts](/concepts/scripts) for the full script model.

## Vendor dependencies

If your route scripts import npm packages, add a `package.json` at the project root and install your dependencies. At build time, the bundler resolves external imports, deduplicates shared packages into a single `vendor.js`, and rewrites route bundles to reference it. The deployed artifact has no dependency on `node_modules/`.
