---
title: Project structure
description: Filesystem conventions and directory layout for Hyperterse projects.
---

Hyperterse uses the filesystem as the source of truth. You define database connections in adapter files and tools in tool directories. File names become identifiers. The framework discovers everything from the directory structure — you never register adapters or tools manually.

## Directory layout

A typical project looks like this:

<Card>
  <Tree>
    <Tree.File name=".hyperterse" />
    <Tree.File name="package.json" />
    <Tree.Folder
      name="app"
      defaultOpen
    >
      <Tree.Folder
        name="adapters"
        defaultOpen
      >
        <Tree.File name="primary-db.terse" />
        <Tree.File name="cache-store.terse" />
      </Tree.Folder>
      <Tree.Folder
        name="tools"
        defaultOpen
      >
        <Tree.Folder
          name="get-user"
          defaultOpen
        >
          <Tree.File name="config.terse" />
          <Tree.File name="input-validator.ts" />
          <Tree.File name="data-mapper.ts" />
        </Tree.Folder>
        <Tree.Folder
          name="get-weather"
          defaultOpen
        >
          <Tree.File name="config.terse" />
          <Tree.File name="handler.ts" />
        </Tree.Folder>
      </Tree.Folder>
    </Tree.Folder>
  </Tree>
</Card>

## Root configuration

The `.hyperterse` file contains service-level settings: name, version, server port, log level, cache defaults, and build options. It does not contain adapter or tool definitions — those live in `app/`.

When you run `hyperterse start` or `hyperterse build` without arguments, the CLI looks for `.hyperterse` in the current directory. See [Root configuration reference](/reference/root-config) for the complete field specification.

## Adapter discovery

The compiler scans `app/adapters/*.terse` at build time. Each file defines exactly one adapter. The filename (without extension) becomes the adapter's identifier, unless the file explicitly sets a `name` field.

See [Adapters](/concepts/adapters) for how adapters work, and [Adapter configuration reference](/reference/adapter-config) for the field specification.

## Tool discovery

The compiler scans `app/tools/*/config.terse` at build time. Each `config.terse` file defines one MCP tool. The directory name becomes the tool name, unless the file explicitly sets a `name` field.

Every tool must define either a database connection (`use`) or a handler script (`handler`). Tools with neither are rejected during validation.

See [Tools](/concepts/tools) for execution models, and [Tool configuration reference](/reference/tool-config) for the field specification.

## Script resolution

Script paths in tool configs are resolved relative to the tool directory. You can declare them explicitly, or rely on convention-based discovery. Common conventions include `handler.ts`, `input.ts`, and `output.ts`.

See [Scripts](/concepts/scripts) for the full script model.

## Vendor dependencies

If your tool scripts import npm packages, add a `package.json` at the project root and install your dependencies. Build output includes everything needed to run scripts, so deployment does not depend on `node_modules/` being present.
