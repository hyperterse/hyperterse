---
title: Project structure
description: Filesystem conventions and directory layout for Hyperterse projects.
---

Hyperterse uses the filesystem as the source of truth. You define database connections in adapter files and tools in tool directories. File names become identifiers. The framework discovers everything from the directory structure — you never register adapters or tools manually.

## Directory layout

A typical project looks like this:

```
project-root/
├── .hyperterse                        # Root service configuration
├── package.json                       # npm dependencies for scripts (optional)
├── app/
│   ├── adapters/
│   │   ├── primary-db.terse           # Adapter: PostgreSQL
│   │   └── cache-store.terse          # Adapter: Redis
│   └── tools/
│       ├── get-user/
│       │   ├── config.terse           # Tool configuration
│       │   ├── input-validator.ts     # Input transform script
│       │   └── data-mapper.ts         # Output transform script
│       └── get-weather/
│           ├── config.terse           # Tool configuration
│           └── handler.ts             # Custom handler script
```

## Root configuration

The `.hyperterse` file contains service-level settings: name, version, server port, log level, cache defaults, and build options. It does not contain adapter or tool definitions — those live in `app/`.

When you run `hyperterse start` or `hyperterse build` without arguments, the CLI looks for `.hyperterse` in the current directory. See [Root configuration reference](/reference/root-config) for the complete field specification.

## Adapter discovery

The compiler scans `app/adapters/*.terse` at build time. Each file defines exactly one adapter. The filename (without extension) becomes the adapter's identifier, unless the file explicitly sets a `name` field.

See [Adapters](/concepts/adapters) for how adapters work, and [Adapter configuration reference](/reference/adapter-config) for the field specification.

## Tool discovery

The compiler scans `app/tools/*/config.terse` at build time. Each `config.terse` file defines one MCP tool. The directory name becomes the tool name, unless the file explicitly sets a `name` field.

Every tool must define either a database connection (`use`) or a handler script (`scripts.handler`). Tools with neither are rejected during validation.

See [Tools](/concepts/tools) for execution models, and [Tool configuration reference](/reference/tool-config) for the field specification.

## Script resolution

Script paths in tool configs are resolved relative to the tool directory. You can declare them explicitly, or rely on convention-based discovery where files matching naming patterns (like `*handler*.ts`) are automatically picked up.

See [Scripts](/concepts/scripts) for the full script model.

## Vendor dependencies

If your tool scripts import npm packages, add a `package.json` at the project root and install your dependencies. At build time, the bundler resolves external imports, deduplicates shared packages into a single `vendor.js`, and rewrites tool bundles to reference it. The deployed artifact has no dependency on `node_modules/`.
