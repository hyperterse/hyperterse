---
title: Build and Serve
description: Production packaging with manifest serialization, deployment workflows, container builds, and environment configuration.
---

## Overview

Hyperterse separates compilation from execution. `hyperterse build` compiles configuration, bundles scripts, and serializes everything into a self-contained output directory. `hyperterse serve` boots the runtime from that pre-built output without re-parsing source files.

This separation provides:
- **Deterministic deployments** — The exact manifest that was validated is the one that runs.
- **Faster startup** — No filesystem scanning, config parsing, or script bundling at boot time.
- **Smaller attack surface** — Source `.terse` files and TypeScript sources are not required in the deployment artifact.

---

## Build

### Command

```bash
hyperterse build -f .hyperterse -o dist
```

### What Build Produces

| Artifact | Description |
|---|---|
| `dist/hyperterse` | Runtime binary (platform-specific) |
| `dist/model.bin` | Serialized `Model` + `FrameworkManifest` (protobuf binary) |
| `dist/build/vendor.js` | Shared npm dependency bundle (if route scripts import external packages) |
| `dist/build/routes/<name>/*.js` | Per-route script bundles (handler, input_transform, output_transform) |

### Build Process

1. Parse root config and validate.
2. Discover and compile adapters and routes from `app/`.
3. Resolve script paths and validate TypeScript files.
4. Bundle scripts with esbuild — vendor bundle + per-route bundles.
5. Serialize the complete model and framework manifest to `model.bin`.
6. Copy the runtime binary to the output directory.

### Build Flags

| Flag | Short | Default | Description |
|---|---|---|---|
| `--file` | `-f` | `.hyperterse` | Root config file path. |
| `--out` | `-o` | `dist` | Output directory. |
| `--clean-dir` | | `false` | Remove output directory before building. |

---

## Serve

### Command

```bash
hyperterse serve dist/
```

Or explicitly:

```bash
hyperterse serve -f dist/model.bin
```

### What Serve Does

1. Load and deserialize `model.bin`.
2. Reconstruct the `Project` from the `FrameworkManifest` (routes, bundles, adapters).
3. Initialize connectors for all referenced adapters.
4. Register MCP tools.
5. Start the HTTP server.

### Serve Flags

| Flag | Short | Description |
|---|---|---|
| `--file` | `-f` | Path to `model.bin` or directory containing it. |

---

## Recommended Deployment Workflow

```
┌──────────────────────────────────────────────────┐
│  1. hyperterse validate -f .hyperterse           │
│  2. hyperterse build -f .hyperterse -o dist      │
│  3. Test locally: cd dist && ./hyperterse serve   │
│  4. Ship dist/ to target environment              │
│  5. Run: ./hyperterse serve                       │
└──────────────────────────────────────────────────┘
```

Validate before building. Build once, deploy the artifact. Do not rebuild in the target environment.

---

## Container Deployment

### Dockerfile

```dockerfile
FROM golang:1.22-alpine AS builder
WORKDIR /src
COPY . .
RUN go mod download && make generate && make build

FROM alpine:3.19
RUN apk add --no-cache ca-certificates
RUN adduser -D -u 1001 hyperterse
COPY --from=builder /src/dist/ /app/
WORKDIR /app
USER hyperterse
EXPOSE 8080
ENTRYPOINT ["./hyperterse", "serve"]
```

### Minimal Image (Pre-Built)

If you build locally or in CI and only need to package the output:

```dockerfile
FROM alpine:3.19
RUN apk add --no-cache ca-certificates
RUN adduser -D -u 1001 hyperterse
COPY dist/ /app/
WORKDIR /app
USER hyperterse
EXPOSE 8080
ENTRYPOINT ["./hyperterse", "serve"]
```

### Scratch Image

For the smallest possible image (no shell, no package manager):

```dockerfile
FROM scratch
COPY dist/hyperterse /hyperterse
COPY dist/model.bin /model.bin
COPY dist/build/ /build/
EXPOSE 8080
ENTRYPOINT ["/hyperterse", "serve"]
```

Note: The `scratch` image requires the Hyperterse binary to be statically linked. The default Go build produces a static binary.

---

## Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hyperterse
spec:
  replicas: 3
  selector:
    matchLabels:
      app: hyperterse
  template:
    metadata:
      labels:
        app: hyperterse
    spec:
      containers:
        - name: hyperterse
          image: registry.example.com/hyperterse:latest
          ports:
            - containerPort: 8080
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: db-credentials
                  key: url
            - name: API_KEY
              valueFrom:
                secretKeyRef:
                  name: api-credentials
                  key: key
          livenessProbe:
            httpGet:
              path: /heartbeat
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /heartbeat
              port: 8080
            initialDelaySeconds: 3
            periodSeconds: 5
          resources:
            requests:
              memory: "64Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
          securityContext:
            readOnlyRootFilesystem: true
            runAsNonRoot: true
            runAsUser: 1001
```

---

## CI/CD Integration

### GitHub Actions Example

```yaml
name: Build and Deploy
on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.22'
      - run: make generate && make build
      - run: ./dist/hyperterse validate -f .hyperterse
      - run: ./dist/hyperterse build -f .hyperterse -o dist
      - uses: actions/upload-artifact@v4
        with:
          name: hyperterse-dist
          path: dist/
```

---

## Environment Configuration

The `dist/` directory contains no secrets. All credentials are supplied via environment variables at runtime:

| Variable | Purpose |
|---|---|
| `DATABASE_URL` | Connection string for primary database adapter |
| `API_KEY` | API key for route authentication |
| `PORT` | Server port override |

Set these in your deployment platform's secrets management:
- **Docker Compose** — `env_file` or `environment` in `docker-compose.yml`.
- **Kubernetes** — `Secret` resources mapped to `env`.
- **ECS / Cloud Run** — Environment variable configuration in task/service definitions.
- **Railway / Render / Fly** — Platform secrets dashboard.

---

## Horizontal Scaling

Hyperterse runs as a single-process stateless server. Scale horizontally by running multiple instances behind a load balancer:

- Each instance maintains its own in-memory cache (no cache sharing).
- No inter-instance coordination is required.
- Use sticky sessions if MCP session management is needed (Mcp-Session-Id header).
- All instances must have access to the same database endpoints and environment variables.
