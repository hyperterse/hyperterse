---
title: Production Hardening
description: Security considerations, deployment configuration, and hardening measures for running Hyperterse in production environments.
---

## Overview

This page covers security measures beyond input validation. It addresses network security, authentication enforcement, logging hygiene, and deployment architecture decisions that affect the security posture of a Hyperterse deployment.

---

## Authentication

### Enforce auth on every sensitive route

Auth is per-route, not global. There is no server-wide authentication middleware. Every route that accesses sensitive data or performs mutations must declare an `auth` block:

```yaml
auth:
  plugin: api_key
  policy:
    value: "{{ env.ROUTE_API_KEY }}"
```

**Audit checklist:**
- Review all `config.terse` files for missing `auth` blocks.
- `allow_all` should only be used for health checks and intentionally public tools.
- Use `hyperterse validate` to confirm all routes are well-formed, then manually verify auth presence.

### Rotate credentials

API keys and tokens referenced via `{{ env.VAR }}` are resolved at startup. Rotation requires a runtime restart. For zero-downtime rotation:

1. Update the secret in your secrets manager.
2. Trigger a rolling restart of runtime instances.
3. Verify the old key is rejected after all instances have restarted.

---

## Network security

### TLS termination

Hyperterse does not perform TLS termination natively. Deploy behind a reverse proxy or load balancer that handles TLS:

- **Nginx** — `proxy_pass` to `http://localhost:8080`.
- **Caddy** — Automatic HTTPS with Let's Encrypt.
- **AWS ALB / GCP LB** — Managed TLS with certificate manager.
- **Kubernetes Ingress** — TLS via cert-manager or cloud provider integration.

All client-facing traffic should use HTTPS. The Hyperterse runtime can listen on a private network interface or loopback address.

### CORS configuration

The runtime applies permissive CORS headers by default (all origins, standard methods and headers). For production:

1. Deploy behind a reverse proxy.
2. Configure restrictive CORS at the proxy level.
3. Restrict the runtime's CORS to your application domain or disable it entirely when the proxy handles CORS.

### Network segmentation

- Place the runtime in a private network segment.
- Restrict inbound traffic to the reverse proxy or load balancer only.
- Restrict outbound traffic from the runtime to database hosts and any external APIs used by handler scripts.
- Block direct internet access to the runtime port.

---

## Logging hygiene

### Log level

Set the production log level to `2` (warn) or `3` (info):

```yaml
server:
  log_level: 2
```

Debug-level logging (`4`) may include substituted statement text, input values, and internal execution details. This is acceptable in development but poses a data exposure risk in production.

### Log routing

Use `--log-file` to write logs to a file for collection by a log aggregation system (Fluentd, Vector, CloudWatch agent, etc.). Avoid logging to stdout in containerized environments where stdout is captured to a shared log store with broad read access.

### Sensitive data in logs

- Connection strings are redacted in trace attributes.
- Input values may appear in debug-level logs.
- Handler script `console.log` output is written to the log stream at the script's discretion — review scripts for accidental credential logging.

---

## Container security

### Minimal base image

Use a minimal base image for the runtime binary:

```dockerfile
FROM scratch
COPY dist/hyperterse /hyperterse
COPY dist/model.bin /model.bin
COPY dist/build/ /build/
ENTRYPOINT ["/hyperterse", "serve"]
```

Or use `alpine` if you need shell access for debugging:

```dockerfile
FROM alpine:3.19
RUN apk add --no-cache ca-certificates
COPY dist/ /app/
WORKDIR /app
ENTRYPOINT ["./hyperterse", "serve"]
```

### Non-root execution

Run the container as a non-root user:

```dockerfile
RUN adduser -D -u 1001 hyperterse
USER hyperterse
```

### Read-only filesystem

Mount the container filesystem as read-only. Hyperterse does not write to disk at runtime (cache is in-memory):

```yaml
securityContext:
  readOnlyRootFilesystem: true
```

---

## Secrets management

### Do not embed secrets in config

All credentials (database passwords, API keys, tokens) should be supplied via environment variables:

```yaml
connection_string: "{{ env.DATABASE_URL }}"
```

### Secrets in Kubernetes

Use Kubernetes secrets mounted as environment variables:

```yaml
env:
  - name: DATABASE_URL
    valueFrom:
      secretKeyRef:
        name: db-credentials
        key: url
```

### External secrets managers

For environments using AWS Secrets Manager, HashiCorp Vault, or similar:

1. Use a sidecar or init container to fetch secrets and inject them as environment variables.
2. Signal the runtime to restart when secrets rotate.
3. Do not mount secrets as files — Hyperterse reads from environment variables, not the filesystem.

---

## Rate limiting

Hyperterse does not include built-in rate limiting. Implement rate limiting at the infrastructure layer:

- **Reverse proxy** — Nginx `limit_req`, Caddy `rate_limit`, Envoy rate limit filter.
- **API gateway** — AWS API Gateway throttling, Kong rate limiting, Traefik middleware.
- **Cloud provider** — Cloud Armor, AWS WAF, Azure Front Door rate rules.

Rate limiting should be applied to the `/mcp` endpoint, which handles all tool invocations.

---

## Health checks and monitoring

### Liveness probe

The `/heartbeat` endpoint confirms the HTTP server is accepting connections:

```bash
curl http://localhost:8080/heartbeat
```

Use this as a liveness probe in container orchestrators. It does not verify connector health.

### Readiness probe

For readiness checks that verify full system health (including connector connectivity), implement a custom tool that queries each adapter and reports status:

```yaml
# app/routes/readiness/config.terse
description: "Readiness check"
use: primary-db
statement: "SELECT 1"
auth:
  plugin: allow_all
```

### Metrics

When observability is enabled, expose the metrics endpoint to your monitoring system (Prometheus, Datadog, etc.). Monitor:

- Tool invocation rate and latency.
- Error rates by tool and error type.
- Cache hit ratio.
- Connector execution time.

---

## Deployment checklist

- [ ] All sensitive routes have `auth` blocks.
- [ ] No `allow_all` on routes that access sensitive data.
- [ ] Credentials supplied via environment variables, not plaintext config.
- [ ] `.env` file excluded from version control (`.gitignore`).
- [ ] TLS termination configured at reverse proxy or load balancer.
- [ ] CORS restricted to application domain.
- [ ] Log level set to `2` or `3`.
- [ ] Container runs as non-root user.
- [ ] Runtime port not exposed to public internet.
- [ ] Rate limiting configured at infrastructure layer.
- [ ] Health check and readiness probes configured.
- [ ] Observability enabled for tracing and metrics.
