---
title: Connection security
description: Protect database credentials and connections in Hyperterse.
---

import Aside from '@/components/admonition.astro'
import { Danger } from '@astrojs/starlight/components'

<Aside
  type="caution"
  title="CAUTION"
>
  These instructions are a work in progress. Please report any issues or
  suggestions to the [GitHub
  repository](https://github.com/hyperterse/hyperterse/issues/new?template=documentation.yml).
</Aside>

## Environment variables

<Aside type="danger">
  **Avoid hardcoding credentials** in configuration files. Using environment
  variables is safer and more flexible.
</Aside>

### Using environment variables

Reference environment variables in connection strings:

```yaml
adapters:
  production_db:
    connector: postgres
    connection_string: '{{ env.DATABASE_URL }}'
```

Or construct from multiple variables:

```yaml
adapters:
  production_db:
    connector: postgres
    connection_string: 'postgresql://${DB_USER}:${DB_PASS}@${DB_HOST}:5432/${DB_NAME}'
```

### Setting environment variables

**Local development:**

```bash
export DATABASE_URL="postgresql://dev:dev@localhost:5432/myapp"
hyperterse dev -f config.terse
```

**Using .env files:**

```bash
# .Env
DATABASE_URL=postgresql://dev:dev@localhost:5432/myapp

# Load before running
source .env && hyperterse dev -f config.terse
```

**In Docker:**

```dockerfile
ENV DATABASE_URL=postgresql://user:pass@db:5432/app
```

## SSL/TLS connections

We recommend ensuring all production connections are encrypted.

### PostgreSQL

```yaml
adapters:
  production_db:
    connector: postgres
    connection_string: 'postgresql://user:pass@host:5432/db?sslmode=require'
```

SSL modes:

| Mode          | Description                   | Use Case            |
| ------------- | ----------------------------- | ------------------- |
| `disable`     | No SSL                        | Non-production only |
| `require`     | SSL required, no verification | Cloud databases     |
| `verify-ca`   | Verify CA certificate         | High security       |
| `verify-full` | Verify CA and hostname        | Highest security    |

### MySQL

```yaml
adapters:
  production_db:
    connector: mysql
    connection_string: 'user:pass@tcp(host:3306)/db?tls=true'
```

### Redis

Use `rediss://` for TLS:

```yaml
adapters:
  cache:
    connector: redis
    connection_string: 'rediss://:password@host:6379/0'
```

## Least privilege access

Create database users with minimal permissions:

### PostgreSQL

```sql
-- Create read-only user
CREATE USER hyperterse WITH PASSWORD 'secure_password';

-- Grant only SELECT on specific tables
GRANT SELECT ON users, products, orders TO hyperterse;

-- For new tables
ALTER DEFAULT PRIVILEGES IN SCHEMA public
  GRANT SELECT ON TABLES TO hyperterse;
```

### MySQL

```sql
-- Read-only access
CREATE USER 'hyperterse'@'%' IDENTIFIED BY 'secure_password';
GRANT SELECT ON myapp.* TO 'hyperterse'@'%';
```

<Aside type="caution">
  If your queries include INSERT, UPDATE, or DELETE, grant only those specific
  permissions on specific tables.
</Aside>

## Network security

### Private networks

Keep databases on private networks:

```
┌─────────────────────────────────────────────────────┐
│                    Private VPC                      │
│                                                     │
│  ┌─────────────┐         ┌─────────────┐           │
│  │ Hyperterse  │────────▶│   Database  │           │
│  │   Server    │ Private │             │           │
│  └──────▲──────┘  Net    └─────────────┘           │
│         │                                           │
└─────────┼───────────────────────────────────────────┘
          │ Public
    ┌─────┴─────┐
    │  Clients  │
    └───────────┘
```

### Firewall rules

- Allow Hyperterse to connect to database ports
- Block direct database access from the internet
- Restrict Hyperterse port (8080) to expected sources

### Cloud examples

**AWS:**

- Use RDS in a private subnet
- Security groups allowing Hyperterse instances only
- Deploy Hyperterse in the same VPC

**GCP:**

- Use Cloud SQL with private IP
- VPC network for Hyperterse
- Firewall rules restricting access

## Secrets management

For production, use a secrets manager:

### AWS secrets Manager

```bash
# Fetch secret at runtime
export DATABASE_URL=$(aws secretsmanager get-secret-value \
  --secret-id prod/db/hyperterse \
  --query SecretString --output text)

hyperterse run -f config.terse
```

### Hashicorp vault

```bash
export DATABASE_URL=$(vault kv get -field=url secret/database)
hyperterse run -f config.terse
```

### Kubernetes secrets

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: hyperterse-secrets
stringData:
  DATABASE_URL: postgresql://user:pass@db:5432/app
---
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
        - name: hyperterse
          envFrom:
            - secretRef:
                name: hyperterse-secrets
```

## Connection pooling

Configure connection pools appropriately:

```yaml
adapters:
  production_db:
    connector: postgres
    connection_string: '${DATABASE_URL}'
    options:
      max_connections: '10' # Match expected concurrency
```

**Sizing guidelines:**

- Start with 5-10 connections per Hyperterse instance
- Monitor database connection usage
- Increase if you see connection wait times

<Aside>
  If using database connection poolers (PgBouncer, ProxySQL), you may reduce
  Hyperterse's pool size.
</Aside>

## Credential rotation

Plan for credential rotation:

1. Create new database user with new password
2. Update secrets manager
3. Restart Hyperterse (connections are re-established)
4. Revoke old credentials

For zero-downtime rotation, use multiple Hyperterse instances with rolling restarts.
