---
title: MCP transport
description: Streamable HTTP endpoint, JSON-RPC protocol surface, request formats, CORS, and session management.
---

Hyperterse is an MCP server. All tool interaction — discovery and execution — goes through a single endpoint using the MCP Streamable HTTP transport over JSON-RPC 2.0. There are no per-tool REST endpoints, no GraphQL layer, and no custom protocol. The transport is the protocol, and the protocol is MCP.

## Endpoints

| Endpoint     | Methods                 | Purpose                                                                         |
| ------------ | ----------------------- | ------------------------------------------------------------------------------- |
| `/mcp`       | `GET`, `POST`, `DELETE` | MCP Streamable HTTP. Handles `tools/list`, `tools/call`, and session lifecycle. |
| `/heartbeat` | `GET`                   | Returns `{"success": true}` when the server is accepting connections.           |

## `tools/list`

Returns all registered tools with their input schemas.

**Request:**

```json
{
  "jsonrpc": "2.0",
  "method": "tools/list",
  "id": 1
}
```

**Response:**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "get-user",
        "description": "Retrieve a user by their identifier",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user_id": {
              "type": "integer",
              "description": "Primary key of the user record"
            }
          },
          "required": ["user_id"]
        }
      }
    ]
  }
}
```

### Schema generation

Input schemas are generated from the route's `inputs` block:

| `.terse` type | JSON Schema type |
| ------------- | ---------------- |
| `string`      | `"string"`       |
| `int`         | `"integer"`      |
| `float`       | `"number"`       |
| `boolean`     | `"boolean"`      |
| `datetime`    | `"string"`       |

Required inputs (non-optional, no default) appear in the `required` array.

## `tools/call`

Executes a tool with the provided arguments.

**Request:**

```json
{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "get-user",
    "arguments": {
      "user_id": 42
    }
  },
  "id": 2
}
```

**Successful response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "[{\"id\":42,\"name\":\"Jane Doe\",\"email\":\"jane@example.com\"}]"
      }
    ]
  }
}
```

The `content` array contains one text entry with JSON-encoded results. For DB-backed routes, this is the serialized row set. For handler routes, this is the serialized return value.

**Error response:**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "error": {
    "code": -32000,
    "message": "execution failed: user_id must be a positive integer"
  }
}
```

Errors from auth failures, input validation, connector execution, and script exceptions are returned as JSON-RPC error objects. Stack traces are logged but not exposed.

## Heartbeat

```bash
curl http://localhost:8080/heartbeat
```

```json
{ "success": true }
```

The heartbeat bypasses the MCP handler and auth pipeline. It returns `200 OK` when the HTTP server is accepting connections, regardless of connector health.

## CORS

The runtime applies CORS headers to all responses:

- **Origins:** `*` (all)
- **Methods:** `GET`, `POST`, `DELETE`, `OPTIONS`
- **Headers:** `Content-Type`, `Authorization`, `X-API-Key`, `Mcp-Session-Id`

Preflight (`OPTIONS`) requests are handled automatically. For production deployments behind a reverse proxy, configure CORS at the proxy layer and restrict the built-in policy to your domain.

## HTTP headers in the execution context

HTTP request headers from `tools/call` requests are forwarded into the execution pipeline. Auth plugins access them through `framework.RequestHeadersFromContext(ctx)`. This makes `X-API-Key`, `Authorization`, and any custom headers available for authentication decisions.

## Session management

The MCP Streamable HTTP transport supports session-based interaction via the `Mcp-Session-Id` header. `DELETE /mcp` terminates a session.

For stateless tool invocation — the common case — sessions are not required. Each `POST /mcp` with a `tools/call` method is independently executed.

## Internal service contracts

The runtime defines two RPC services:

- **MCPService** — `ListTools` and `CallTool`. Active in the current runtime, mapped to the MCP JSON-RPC methods.
- **QueryService** — `ExecuteQuery`. Defined but not registered. Reserved for potential direct HTTP query endpoints in future versions.
